{"name":"BkTask","tagline":"An asynchronous workflows library for iOS","body":"# BkTask\r\nBkTask is a library inspired by the [Proactor](http://en.wikipedia.org/wiki/Proactor_pattern \"Proactor pattern on Wikipedia\") and [Reactor](http://en.wikipedia.org/wiki/Reactor_pattern \"Reactor pattern on Wikipedia\") design patterns. It is designed with two concepts in mind, asynchronous and modular.  \r\nDoing work asynchronously allows to keep your application responsive. But parallel programming is hard. On iOS, tools like GCD and NSOperation makes it much simpler but, for complex workflows it still takes time and resources to achieve. BkTask allows you to simply run workflows in background and be notified once it is done.  \r\n\r\nWhat about modularity then ? One way to simply a complex task is to breaking it into multiple simple steps. That is how you build a task with BkTask, by adding the steps you need to complete your workflow. If your workflow changes, add or remove steps to update it. You can even create your own steps and reuse them in different workflows. The modular aspect of BkTask helps you to stay agile.\r\n\r\nOn the technical side, it is built using technologies like NSOperation and key-value observing.  \r\nThis library is already used in AppStore applications used by millions of people. \r\n\r\n## Changes\r\nv 0.8  \r\n\r\n* ARC Conversion\r\n* Added Weather sample project\r\n* Code documentation in appledoc format\r\n\r\n## Getting started\r\n### Xcode configuration\r\nThe simplest way to use BkTask with your project is with Xcode 4 workspaces. Just drag and drop `BkTask.xcodeproj` below your other projects in the workspace.  \r\n![Drop BkTask xcodeproj into your workspace](https://github.com/Backelite/BkTask/raw/master/Images/BkTask_1.jpg \"Drop BkTask xcodeproj into your workspace\")  \r\n\r\nThen, select your project's target and click on the `Build Phases` tab. Unfold the `Link Binary With Libraries` section and click on the + button to add a new library.\r\nSelect `libBkTask.a` and click `Add`.  \r\n![Add libBkTask.a to your target](https://github.com/Backelite/BkTask/raw/master/Images/BkTask_2.jpg \"Add libBkTask.a to your target\")  \r\n\r\nAs it is a static library, you will need to indicate the path to BkTask headers. To do so, select your project's target and click on the `Build Settings` tab. Find the `Header Search Paths` and set the path to the `Classes` directory of BkTask.\r\nFor instance, let's assume that you have a `Libraries` directory at the same level of your `.xcodeproj` where you store all your external libraries. In that case, the header to indicate would be `$(SRCROOT)/Librairies/BkTask/Classes`.  \r\n![Add BkTask headers to your Header Search Paths](https://github.com/Backelite/BkTask/raw/master/Images/BkTask_3.jpg \"Add BkTask headers to your Header Search Paths\")  \r\n\r\n__To make this step even easier, support for cocoapods is coming soon.__\r\n\r\n-------\r\n\r\n### Using BkTask\r\n\r\n#### Anatomy of a task\r\nA _task_ is made of multiple _steps_ sharing a _content_ between them. A _task_ monitor _step_ execution and ensure that _content_ is passed through steps. When all the _steps_ are finished, the _task_ notify every observer registered by calling a success block. If one _step_ fails to execute, the _task_ notify observers by calling a failure block. Note that observers for success and failure may be different.  \r\nA _step_ takes data from its input, process them and return the result through its output. The _content_ is processed by each _step_ and is returned when each step has completed.  \r\nA few things to know : \r\n\r\n* Observers are not retained by a task\r\n* If all observers are removed, the task will stop executing automatically\r\n* A task doesn't retain itself. This means you have to keep ownership a the task until its execution finished or is canceled.\r\n\r\n#### Let's code now\r\n##### The most basic task ever\r\n\r\nFirst, add BkTask import\r\n\r\n\t#import \"BkTask.h\"\r\n\r\nNow we can create a simple task to load a file from disk\r\n\r\n```Objective-C\r\n\r\n\t//Create a task\r\n\tBKTTask *aTask = [[BKTTask alloc] init];\r\n\r\n\t//Create a file load step\r\n\tBKTFileLoadingOperation *fileLoadOperation = [BKTFileLoadingOperation loadOperationWithFile:FILE_TO_OPEN_URL];\r\n\r\n\t//Add the step to the task\r\n\t[aTask addStep:fileLoadOperation];\r\n\r\n\t//Set completion and failure blocks\r\n\t[aTask addTarget:self completion:^(BKTTask *task, id output) {\r\n    NSLog(@\"Task completed with success\");\r\n\t}];\r\n\t[aTask addTarget:self failure:^(BKTTask *task, NSError *error) {\r\n    NSLog(@\"Task failed\");\r\n\t}];\r\n\r\n\t//Start the task\r\n\tself.myTask = aTask; //To retain the task\r\n\t[self.myTask start];\r\n```\r\n\r\nOf course, a task with one step is not very usefull and GCD is better at that. However, when you have a workflow with multiple steps, it becomes a mess of nested blocks with GCD while BkTask takes care of chaining steps and passing data through them.\r\n\r\n##### Quick tasks\r\n\r\nFor frequent use cases, there are helper methods to build preconfigured tasks.  \r\n```Objective-C\r\n\r\n\t// To create a task with a download URL step\r\n\t+ (id) taskWithRequest:(NSURLRequest *)aRequest;\r\n\r\n\t// To create a task with a download URL step and a JSON parsing step\r\n\t+ (id) taskWithJSONRequest:(NSURLRequest *)aRequest;\r\n```\r\n\r\n##### Making your own steps\r\nSometimes, you may have application specific work to execute in background. Or you may want to replace the default JSON parsing step with a step using your favorite JSON parsing library. Or simply, there is no existing step to do what you want.  \r\nBkTask offers multiple ways for creating custom steps. If your step is quite simple and meant to be use only once, you can use `BkBlockStepOperation` with a block describing how to process the data in your step.\r\n\r\n```Objective-C\r\n\r\n\t+ (id) blockOperationWithInputKey:(NSString *)inKey outputKey:(NSString *)outKey block:(BKTBlockStepOperationBlock)workBlock;\r\n\t\r\n\t+ (id) blockOperationWithQueue:(NSOperationQueue *)queue block:(BKTBlockStepOperationBlock)workBlock;\r\n\t\r\n\t+ (id) blockOperationWithBlock:(BKTBlockStepOperationBlock)workBlock;\r\n```\r\n\r\nThe `inKey` and `outKey` parameters can take two values :\r\n\r\n* `BkTaskContentBodyData` means your input (or output respectively) is binary data in a NSData object\r\n* `BkTaskContentBodyObject` means your input (or output respectively) is NSObject subclass\r\n\r\nThe ouput type of one step have to be identical to the input of the next step. Otherwise, the task would fail to complete.    \r\n\r\nTo deeply customize a step, or if you need a reusable step, you can subclass `BKTBasicStepOperation`. A step is an `NSOperation` subclass implementing the `BKTTaskStep` protocol. `BKTBasicStepOperation` is an abstract class implementing the boilerplate parts to provide a much simpler API to create a class. All you need to do is to override the following methods :\r\n\r\n```Objective-C\r\n\r\n\t- (NSString *) inputKey;\r\n\t\r\n\t- (NSString *) outputKey;\r\n\t\r\n\t- (id) processInput:(id)theInput error:(NSError **)error;\r\n```\r\n\r\nThe implementation of `inputKey` and `outputKey` should return `BkTaskContentBodyData` or `BkTaskContentBodyObject` depending on what kind of input your step will process. Then, the `processInput: error:` method is where the input processing is done, returning the output. Of course, subclassing `BKTBasicStepOperation` allows you to add any property or method you need to configure and process the input.    \r\n\r\nIf you create a generic step and think it could be useful to other people, feel free to send a pull request. We would be glad to consider and add it to BkTask.\r\n\r\n-------\r\n\r\n### Sample project\r\nThe sample project is a little weather application. You can search for a city and see related forecasts. It demonstrates how to create a task that will download and parse JSON. It also shows how to add a simple custom step to a task using the block method. To see a sample of `BKTBasicStepOperation` subclassing, you can read the source of `BKTJSONParsingOperation`.  \r\nIs is intented to run on iOS 6.0 an above. We recommend using Xcode 4.6.2 and above to build it.\r\n\r\n## Requirements\r\nBkTask requires iOS 5.0 and above. If you need iOS 4.3 compatibility, you can exclude the `BKTJSONParsingOperation` class of the BkTask target and it should be okay. \r\nHowever this tip is not guaranteed to stay true in future releases.  \r\nXcode 4.6.2 is required to build the BkTask project.\r\n\r\n### ARC\r\nBkTask uses ARC.  \r\nIf you are using BkTask in your non-arc project, you will need to set a `-fobjc-arc` compiler flag on all of the BkTask source files.  \r\nTo set a compiler flag in Xcode, go to your active target and select the \"Build Phases\" tab. Now select all BkTask source files, press Enter, insert -fobjc-arc and then \"Done\" to enable ARC for BkTask.     \r\n\r\nIf you use Xcode 4 workspaces with BkTask included as a project into your workspace then you don't need any specific configuration related to ARC.\r\n\r\n## Licence\r\nBkTask is available under the MIT license. See the LICENSE file for more info.\r\n","google":"UA-44164731-1","note":"Don't delete this file! It's used internally to help with page regeneration."}